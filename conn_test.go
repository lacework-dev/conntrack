package conntrack

import(
	"fmt"
	"testing"
)

func TestCtrack1(t *testing.T){

//	attrs := make([]Attr, 20)
	conn := &Conn{}

	data:=[]byte{52,0,1,128,20,0,1,128,8,0,1,0,127,0,0,1,8,0,2,0,127,0,0,1,28,0,2,128,5,0,1,0,6,0,0,0,6,0,2,0,168,1,0,0,6,0,3,0,0,22,0,0,52,0,2,128,20,0,1,128,8,0,1,0,127,0,0,1,8,0,2,0,127,0,0,1,28,0,2,128,5,0,1,0,6,0,0,0,6,0,2,0,0,22,0,0,6,0,3,0,168,1,0,0,8,0,12,0,168,160,126,128,8,0,3,0,0,0,1,136,8,0,7,0,0,0,0,120,48,0,4,128,44,0,1,128,5,0,1,0,1,0,0,0,5,0,2,0,7,0,0,0,5,0,3,0,0,0,0,0,6,0,4,0,3,0,0,0,6,0,5,0,0,0,0,0}
	err := parsePayload(data, conn)
	fmt.Println(conn, err)

	data=[]byte{52,0,1,128,20,0,1,128,8,0,1,0,172,16,248,156,8,0,2,0,108,61,73,243,28,0,2,128,5,0,1,0,17,0,0,0,6,0,2,0,0,123,0,0,6,0,3,0,0,123,0,0,52,0,2,128,20,0,1,128,8,0,1,0,108,61,73,243,8,0,2,0,172,16,248,156,28,0,2,128,5,0,1,0,17,0,0,0,6,0,2,0,0,123,0,0,6,0,3,0,0,123,0,0,8,0,3,0,0,0,1,142,8,0,7,0,0,0,0,147,8,0,8,0,0,0,0,0,8,0,12,0,168,160,116,128,8,0,11,0,0,0,0,1}
	err = parsePayload(data, conn)
	fmt.Println(conn, err)

	data=[]byte{52,0,1,128,20,0,1,128,8,0,1,0,172,16,248,156,8,0,2,0,224,0,0,251,28,0,2,128,5,0,1,0,17,0,0,0,6,0,2,0,20,233,0,0,6,0,3,0,20,233,0,0,52,0,2,128,20,0,1,128,8,0,1,0,224,0,0,251,8,0,2,0,172,16,248,156,28,0,2,128,5,0,1,0,17,0,0,0,6,0,2,0,20,233,0,0,6,0,3,0,20,233,0,0,8,0,12,0,168,160,92,192,8,0,3,0,0,0,1,136,8,0,7,0,0,0,0,30}
	err = parsePayload(data, conn)
	fmt.Println(conn, err)

}

func BenchmarkCtrack1(b *testing.B){

	data:=[]byte{52,0,1,128,20,0,1,128,8,0,1,0,127,0,0,1,8,0,2,0,127,0,0,1,28,0,2,128,5,0,1,0,6,0,0,0,6,0,2,0,168,1,0,0,6,0,3,0,0,22,0,0,52,0,2,128,20,0,1,128,8,0,1,0,127,0,0,1,8,0,2,0,127,0,0,1,28,0,2,128,5,0,1,0,6,0,0,0,6,0,2,0,0,22,0,0,6,0,3,0,168,1,0,0,8,0,12,0,168,160,126,128,8,0,3,0,0,0,1,136,8,0,7,0,0,0,0,120,48,0,4,128,44,0,1,128,5,0,1,0,1,0,0,0,5,0,2,0,7,0,0,0,5,0,3,0,0,0,0,0,6,0,4,0,3,0,0,0,6,0,5,0,0,0,0,0}

//	attrs := make([]Attr, 20)
	conn := &Conn{}
	b.ReportAllocs()
	b.ResetTimer()
	for n:=0;n<b.N;n++{
		parsePayload(data, conn)
	}
}
